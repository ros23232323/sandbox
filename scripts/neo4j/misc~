mknode --np "{'name':'Apache Outlaw (IRE)','type':'Horse','profile_url':'/racing/profiles/horse/914744/apache-outlaw'}"
mknode --np "{'name':'Miss R Curtis','type':'Trainer','profile_url':'/racing/profiles/trainer/48366/miss-r-curtis'}"
mknode --np "{'name':'R Johnson','type':'Jockey','profile_url':'/racing/profiles/jockey/238/r-johnson'}"

#mkrel -d OUTGOING -t CONNECTED 1 --rp "{'Airline':'X','Start-Time':'1400'}"


#mknode --np "{'name':Paris}" -v




mkrel -d INCOMING -t TRAINS 3 
mkrel -d INCOMING -t RIDES 4



MERGE (robert:Critic) RETURN robert, labels(robert)

MERGE (charlie:Person:Actor:Addict { name:'Charlie Sheen', age:10 }) RETURN charlie
MERGE (colly:Person { name:'Colette McDermott', age:33 }) RETURN colly


#create new node if one does not already exist
MERGE (ian:Person { name:'Ian Towey', age:36 }) ;

#add remove index
CREATE INDEX ON :Person;

CREATE CONSTRAINT ON (p:Person) ASSERT p.name IS UNIQUE;
CREATE CONSTRAINT ON (h:Horse) ASSERT h.name IS UNIQUE;

CREATE CONSTRAINT ON (p:Person) ASSERT p.name IS UNIQUE;
CREATE CONSTRAINT ON (p:Person) ASSERT p.name IS UNIQUE;
CREATE CONSTRAINT ON (p:Person) ASSERT p.name IS UNIQUE;
CREATE CONSTRAINT ON (p:Person) ASSERT p.name IS UNIQUE;
CREATE CONSTRAINT ON (p:Person) ASSERT p.name IS UNIQUE;

CREATE INDEX ON :Person(name);
CREATE INDEX ON :Tracker(name);
CREATE INDEX ON :Trainer(name);
CREATE INDEX ON :Jockey(name);
CREATE INDEX ON :Horse(name);
CREATE INDEX ON :Runner(name);

DROP INDEX ON :Person(name);
DROP INDEX ON :Tracker(name);
DROP INDEX ON :Trainer(name);
DROP INDEX ON :Jockey(name);
DROP INDEX ON :Horse(name);
DROP INDEX ON :Runner(name);

#add remove constraint
CREATE CONSTRAINT ON (p:Person) ASSERT p.name IS UNIQUE;
DROP CONSTRAINT ON (p:Person) ASSERT p.name IS UNIQUE;

#query for person	
MATCH (p:Person) RETURN p;
MATCH (p:Person {name: 'Ian Towey'}) RETURN p;
MATCH (p:Person {name: 'Ian Towey'}) RETURN p.age;

#delete all Person Nodes
MATCH (n:Person) DELETE n;

#delete all nodes / relations during test
MATCH (n) DETACH DELETE n;

#delete node and any relations going to form it
MATCH (n { name:'Andres' }) DETACH DELETE n


MATCH (dame:Horse { name:'Bermuda Bay (IRE)' }),(runner:Horse { name:'Apache Outlaw (IRE)' }) MERGE (dame)-[r:DAME_OF]->(runner);
MATCH (sire:Horse { name:'Westerner' }),(runner:Horse { name:'Apache Outlaw (IRE)' }) MERGE (sire)-[r:SIRE_OF]->(runner);
MATCH (trainer:Person { name:'Miss R Curtis' }),(runner:Horse { name:'Apache Outlaw (IRE)' }) MERGE (trainer)-[r:TRAINER_OF]->(runner);
MATCH (owner:Person { name:'Owner: Mr G Costelloe' }),(runner:Horse { name:'Apache Outlaw (IRE)' }) MERGE (owner)-[r:OWNER_OF]->(runner);



curl -H "Accept: application/json; charset=UTF-8" -H "Authorization: Basic $(echo -n "neo4j:Lecarr0w" | base64)" http://localhost:7474/user/neo4j
curl -H "Accept: application/json; charset=UTF-8" -H "Authorization: Basic $(echo -n "neo4j:Lecarr0w" | base64)" http://localhost:7474/db/data/


#############query
#find all Nodes with label Trainer
match(t:Trainer) return t;		
#find all Nodes with label Person
match(p:Person) return p;
#find node with label Person and property "name = 'Hector_Caballero'"
MATCH (p:Person { name:'Hector_Caballero' }) return p;
#find node with label Jockey and property "name = 'Hector_Caballero'"
MATCH (j:Jockey { name:'Hector_Caballero' }) return j;
#find node with label Jockey and property "name = 'Hector_Caballero'" with relation to, without regard to type or direction of the relationship.
MATCH (j:Jockey { name:'Hector_Caballero' })--(h:Horse) return j,h;
#directional relationship nothing found
MATCH (j:Jockey { name:'Hector_Caballero' })<--(h:Horse) return j,h;
#directional relationship record found
MATCH (j:Jockey { name:'Hector_Caballero' })-->(h:Horse) return j,h;

#find node of type jockey with property "name='Hector_Caballero'" and directional relationship of type RIDER_OF to any horse node returning  the jockey node and horse nodes
MATCH (j:Jockey { name:'Hector_Caballero' })-[r:RIDER_OF]->(h:Horse) return j,h;
#find node of type jockey with property "name='Hector_Caballero'" and directional relationship of type RIDER_OF to any horse node returning  the relation date
MATCH (j:Jockey { name:'Hector_Caballero' })-[r:RIDER_OF]->(h:Horse) return r.rel_dt;

